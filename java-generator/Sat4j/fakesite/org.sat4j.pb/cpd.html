<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia at Feb 9, 2013 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>CPD Results</title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
    <meta name="Date-Revision-yyyymmdd" content="20130209" />
    <meta http-equiv="Content-Language" content="en" />
        
        </head>
  <body class="composite">
    <div id="banner">
                    <div id="bannerLeft">
                SAT4J pseudo
                </div>
                    <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
            
        
                <div class="xleft">
        <span id="publishDate">Last Published: 2013-02-09</span>
                  &nbsp;| <span id="projectVersion">Version: 2.3.3</span>
                      </div>
            <div class="xright">        
        
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
             
        
                                          <h5>Parent Project</h5>
                  <ul>
                  <li class="none">
                          <a href="../index.html" title="SAT4J">SAT4J</a>
            </li>
          </ul>
                       <h5>Project Documentation</h5>
                  <ul>
                                                                                                                                                                                <li class="collapsed">
                          <a href="project-info.html" title="Project Information">Project Information</a>
                  </li>
                                                                                                                                                                                                                                                <li class="expanded">
                          <a href="project-reports.html" title="Project Reports">Project Reports</a>
                    <ul>
                      <li class="none">
                          <a href="surefire-report.html" title="Surefire Report">Surefire Report</a>
            </li>
                      <li class="none">
                          <a href="xref-test/index.html" title="Test Source Xref">Test Source Xref</a>
            </li>
                      <li class="none">
                          <a href="xref/index.html" title="Source Xref">Source Xref</a>
            </li>
                      <li class="none">
                          <a href="pmd.html" title="PMD Report">PMD Report</a>
            </li>
                      <li class="none">
            <strong>CPD Report</strong>
          </li>
                      <li class="none">
                          <a href="checkstyle.html" title="Checkstyle">Checkstyle</a>
            </li>
                      <li class="none">
                          <a href="findbugs.html" title="FindBugs Report">FindBugs Report</a>
            </li>
                      <li class="none">
                          <a href="testapidocs/index.html" title="Test JavaDocs">Test JavaDocs</a>
            </li>
                      <li class="none">
                          <a href="apidocs/index.html" title="JavaDocs">JavaDocs</a>
            </li>
                      <li class="none">
                          <a href="taglist.html" title="Tag List">Tag List</a>
            </li>
              </ul>
        </li>
          </ul>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                   
        
            </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section"><h2>CPD Results<a name="CPD_Results"></a></h2><p>The following document contains the results of PMD's  <a class="externalLink" href="http://pmd.sourceforge.net/cpd.html">CPD</a> 4.2.5.</p></div><div class="section"><h2>Duplications<a name="Duplications"></a></h2><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/MinWatchPbLong.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MinWatchPbLong.html#108">108</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/MinWatchPbLongCP.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MinWatchPbLongCP.html#111">111</a></td></tr><tr class="b"><td colspan='2'><div><pre>    protected MinWatchPbLongCP(ILits voc, int[] lits, BigInteger[] coefs, // NOPMD
            BigInteger degree, BigInteger sumCoefs) {

        super(lits, coefs, degree, sumCoefs);
        this.voc = voc;

        this.watching = new int[this.coefs.length];
        this.watched = new boolean[this.coefs.length];
        this.activity = 0;
        this.watchCumul = 0;
        this.watchingCount = 0;

    }

    /*
     * This method initialize the watched literals.
     * 
     * This method is only called in the factory methods.
     * 
     * @see org.sat4j.minisat.constraints.WatchPb#computeWatches()
     */
    @Override
    protected void computeWatches() throws ContradictionException {
        assert this.watchCumul == 0;
        assert this.watchingCount == 0;
        for (int i = 0; i &lt; this.lits.length
                &amp;&amp; this.watchCumul - this.coefs[0] &lt; this.degree; i++) {
            if (!this.voc.isFalsified(this.lits[i])) {
                this.voc.watch(this.lits[i] ^ 1, this);
                this.watching[this.watchingCount++] = i;
                this.watched[i] = true;
                // update the initial value for watchCumul (poss)
                this.watchCumul = this.watchCumul + this.coefs[i];
            }
        }

        if (this.learnt) {
            watchMoreForLearntConstraint();
        }

        if (this.watchCumul &lt; this.degree) {
            throw new ContradictionException(&quot;non satisfiable constraint&quot;);
        }
        assert nbOfWatched() == this.watchingCount;
    }

    private void watchMoreForLearntConstraint() {
        // looking for literals to be watched,
        // ordered by decreasing level
        int free = 1;
        int maxlevel, maxi, level;

        while (this.watchCumul - this.coefs[0] &lt; this.degree &amp;&amp; free &gt; 0) {
            free = 0;
            // looking for the literal falsified
            // at the least (lowest ?) level
            maxlevel = -1;
            maxi = -1;
            for (int i = 0; i &lt; this.lits.length; i++) {
                if (this.voc.isFalsified(this.lits[i]) &amp;&amp; !this.watched[i]) {
                    free++;
                    level = this.voc.getLevel(this.lits[i]);
                    if (level &gt; maxlevel) {
                        maxi = i;
                        maxlevel = level;
                    }
                }
            }

            if (free &gt; 0) {
                assert maxi &gt;= 0;
                this.voc.watch(this.lits[maxi] ^ 1, this);
                this.watching[this.watchingCount++] = maxi;
                this.watched[maxi] = true;
                // update of the watchCumul value
                this.watchCumul = this.watchCumul + this.coefs[maxi];
                free--;
                assert free &gt;= 0;
            }
        }
        assert this.lits.length == 1 || this.watchingCount &gt; 1;
    }

    /*
     * This method propagates any possible value.
     * 
     * This method is only called in the factory methods.
     * 
     * @see
     * org.sat4j.minisat.constraints.WatchPb#computePropagation(org.sat4j.minisat
     * .UnitPropagationListener)
     */
    @Override
    protected void computePropagation(UnitPropagationListener s)
            throws ContradictionException {
        // propagate any possible value
        int ind = 0;
        while (ind &lt; this.lits.length
                &amp;&amp; this.watchCumul - this.coefs[this.watching[ind]] &lt; this.degree) {
            if (this.voc.isUnassigned(this.lits[ind])
                    &amp;&amp; !s.enqueue(this.lits[ind], this)) {
                throw new ContradictionException(&quot;non satisfiable constraint&quot;);
            }
            ind++;
        }
    }

    /**
     * build a pseudo boolean constraint. Coefficients are positive integers
     * less than or equal to the degree (this is called a normalized
     * constraint).
     * 
     * @param s
     *            a unit propagation listener
     * @param voc
     *            the vocabulary
     * @param lits
     *            the literals
     * @param coefs
     *            the coefficients
     * @param degree
     *            the degree of the constraint to normalize.
     * @return a new PB constraint or null if a trivial inconsistency is
     *         detected.
     */
    public static MinWatchPbLongCP normalizedMinWatchPbNew(</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/WatchPbLong.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/WatchPbLong.html#460">460</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/WatchPbLongCP.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/WatchPbLongCP.html#496">496</a></td></tr><tr class="b"><td colspan='2'><div><pre>            }

            sort(from, i);
            sort(i, to);
        }

    }

    @Override
    public String toString() {
        StringBuffer stb = new StringBuffer();

        if (this.lits.length &gt; 0) {
            for (int i = 0; i &lt; this.lits.length; i++) {
                stb.append(&quot; + &quot;);
                stb.append(this.coefs[i]);
                stb.append(&quot;.&quot;);
                stb.append(Lits.toString(this.lits[i]));
                stb.append(&quot;[&quot;);
                stb.append(this.voc.valueToString(this.lits[i]));
                stb.append(&quot;@&quot;);
                stb.append(this.voc.getLevel(this.lits[i]));
                stb.append(&quot;]&quot;);
                stb.append(&quot; &quot;);
            }
            stb.append(&quot;&gt;= &quot;);
            stb.append(this.degree);
        }
        return stb.toString();
    }

    public void assertConstraint(UnitPropagationListener s) {
        long tmp = slackConstraint();
        for (int i = 0; i &lt; this.lits.length; i++) {
            if (this.voc.isUnassigned(this.lits[i]) &amp;&amp; tmp &lt; this.coefs[i]) {
                boolean ret = s.enqueue(this.lits[i], this);
                assert ret;
            }
        }
    }

    public void register() {
        assert this.learnt;
        try {
            computeWatches();
        } catch (ContradictionException e) {
            System.out.println(this);
            assert false;
        }
    }

    /**
     * to obtain the literals of the constraint.
     * 
     * @return a copy of the array of the literals
     */
    public int[] getLits() {
        int[] litsBis = new int[this.lits.length];
        System.arraycopy(this.lits, 0, litsBis, 0, this.lits.length);
        return litsBis;
    }

    public ILits getVocabulary() {
        return this.voc;
    }

    /**
     * compute an implied clause on the literals with the greater coefficients.
     * 
     * @return a vector containing the literals for this clause.
     */
    public IVecInt computeAnImpliedClause() {
        long cptCoefs = 0;
        int index = this.coefs.length;
        while (cptCoefs &gt; this.degree &amp;&amp; index &gt; 0) {
            cptCoefs = cptCoefs + this.coefs[--index];
        }
        if (index &gt; 0 &amp;&amp; index &lt; size() / 2) {
            IVecInt literals = new VecInt(index);
            for (int j = 0; j &lt;= index; j++) {
                literals.push(this.lits[j]);
            }
            return literals;
        }
        return null;
    }

    public boolean coefficientsEqualToOne() {
        return false;
    }

    @Override
    public boolean equals(Object pb) {
        if (pb == null) {
            return false;
        }
        // this method should be simplified since now two constraints should
        // have
        // always
        // their literals in the same order
        try {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/MaxWatchPbLong.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MaxWatchPbLong.html#101">101</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/MaxWatchPbLongCP.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MaxWatchPbLongCP.html#101">101</a></td></tr><tr class="b"><td colspan='2'><div><pre>    private MaxWatchPbLongCP(ILits voc, int[] lits, BigInteger[] coefs,
            BigInteger degree, BigInteger sumCoefs) {

        super(lits, coefs, degree, sumCoefs);
        this.voc = voc;

        this.activity = 0;
        this.watchCumul = 0;
        if (coefs.length &gt; MaxWatchPb.LIMIT_FOR_MAP) {
            this.litToCoeffs = new HashMap&lt;Integer, Long&gt;(this.coefs.length);
            for (int i = 0; i &lt; this.coefs.length; i++) {
                this.litToCoeffs.put(this.lits[i], this.coefs[i]);
            }
        } else {
            this.litToCoeffs = null;
        }
    }

    /**
     * All the literals are watched.
     * 
     * @see org.sat4j.pb.constraints.pb.WatchPbLong#computeWatches()
     */
    @Override
    protected void computeWatches() throws ContradictionException {
        assert this.watchCumul == 0;
        for (int i = 0; i &lt; this.lits.length; i++) {
            if (this.voc.isFalsified(this.lits[i])) {
                if (this.learnt) {
                    this.voc.undos(this.lits[i] ^ 1).push(this);
                    this.voc.watch(this.lits[i] ^ 1, this);
                }
            } else {
                // updating of the initial value for the counter
                this.voc.watch(this.lits[i] ^ 1, this);
                this.watchCumul = this.watchCumul + this.coefs[i];
            }
        }

        assert this.watchCumul &gt;= computeLeftSide();
        if (!this.learnt &amp;&amp; this.watchCumul &lt; this.degree) {
            throw new ContradictionException(&quot;non satisfiable constraint&quot;);
        }
    }

    /*
     * This method propagates any possible value.
     * 
     * This method is only called in the factory methods.
     * 
     * @see org.sat4j.minisat.constraints.WatchPb#computePropagation()
     */
    @Override
    protected void computePropagation(UnitPropagationListener s)
            throws ContradictionException {
        // propagate any possible value
        int ind = 0;
        while (ind &lt; this.coefs.length
                &amp;&amp; this.watchCumul - this.coefs[ind] &lt; this.degree) {
            if (this.voc.isUnassigned(this.lits[ind])
                    &amp;&amp; !s.enqueue(this.lits[ind], this)) {
                // because this happens during the building of a constraint.
                throw new ContradictionException(&quot;non satisfiable constraint&quot;);
            }
            ind++;
        }
        assert this.watchCumul &gt;= computeLeftSide();
    }</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/MinWatchPbLong.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MinWatchPbLong.html#284">284</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/MinWatchPbLongCP.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MinWatchPbLongCP.html#286">286</a></td></tr><tr class="b"><td colspan='2'><div><pre>    public boolean propagate(UnitPropagationListener s, int p) {
        assert nbOfWatched() == this.watchingCount;
        assert this.watchingCount &gt; 1;

        // finding the index for p in the array of literals (pIndice)
        // and in the array of watching (pIndiceWatching)
        int pIndiceWatching = 0;
        while (pIndiceWatching &lt; this.watchingCount
                &amp;&amp; (this.lits[this.watching[pIndiceWatching]] ^ 1) != p) {
            pIndiceWatching++;
        }
        int pIndice = this.watching[pIndiceWatching];

        assert p == (this.lits[pIndice] ^ 1);
        assert this.watched[pIndice];

        // the greatest coefficient of the watched literals is necessary
        // (pIndice excluded)
        long maxCoef = maximalCoefficient(pIndice);

        // update watching and watched w.r.t. to the propagation of p
        // new literals will be watched, maxCoef could be changed
        maxCoef = updateWatched(maxCoef, pIndice);

        long upWatchCumul = this.watchCumul - this.coefs[pIndice];
        assert nbOfWatched() == this.watchingCount;

        // if a conflict has been detected, return false
        if (upWatchCumul &lt; this.degree) {
            // conflit
            this.voc.watch(p, this);
            assert this.watched[pIndice];
            assert !isSatisfiable();
            return false;
        } else if (upWatchCumul &lt; this.degree + maxCoef) {
            // some literals must be assigned to true and then propagated
            assert this.watchingCount != 0;
            long limit = upWatchCumul - this.degree;
            for (int i = 0; i &lt; this.watchingCount; i++) {
                if (limit &lt; this.coefs[this.watching[i]]
                        &amp;&amp; i != pIndiceWatching
                        &amp;&amp; !this.voc.isSatisfied(this.lits[this.watching[i]])
                        &amp;&amp; !s.enqueue(this.lits[this.watching[i]], this)) {
                    this.voc.watch(p, this);
                    assert !isSatisfiable();
                    return false;
                }
            }
            // if the constraint is added to the undos of p (by propagation),
            // then p should be preserved.
            this.voc.undos(p).push(this);
        }

        // else p is no more watched
        this.watched[pIndice] = false;
        this.watchCumul = upWatchCumul;
        this.watching[pIndiceWatching] = this.watching[--this.watchingCount];

        assert this.watchingCount != 0;
        assert nbOfWatched() == this.watchingCount;

        return true;
    }</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/MinWatchPbLong.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MinWatchPbLong.html#402">402</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/MinWatchPbLongCP.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MinWatchPbLongCP.html#402">402</a></td></tr><tr class="b"><td colspan='2'><div><pre>        return new MinWatchPbLongCP(voc, mpb);
    }

    /**
     * the maximal coefficient for the watched literals
     * 
     * @param pIndice
     *            propagated literal : its coefficient is excluded from the
     *            search of the maximal coefficient
     * @return the maximal coefficient for the watched literals
     */
    protected long maximalCoefficient(int pIndice) {
        long maxCoef = 0;
        for (int i = 0; i &lt; this.watchingCount; i++) {
            if (this.coefs[this.watching[i]] &gt; maxCoef
                    &amp;&amp; this.watching[i] != pIndice) {
                maxCoef = this.coefs[this.watching[i]];
            }
        }

        assert this.learnt || maxCoef != 0;
        return maxCoef;
    }

    /**
     * update arrays watched and watching w.r.t. the propagation of a literal.
     * 
     * return the maximal coefficient of the watched literals (could have been
     * changed).
     * 
     * @param mc
     *            the current maximal coefficient of the watched literals
     * @param pIndice
     *            the literal propagated (falsified)
     * @return the new maximal coefficient of the watched literals
     */
    protected long updateWatched(long mc, int pIndice) {
        long maxCoef = mc;
        // if not all the literals are watched
        if (this.watchingCount &lt; size()) {
            // the watchCumul sum will have to be updated
            long upWatchCumul = this.watchCumul - this.coefs[pIndice];

            // we must obtain upWatchCumul such that
            // upWatchCumul = degree + maxCoef
            long degreePlusMaxCoef = this.degree + maxCoef;
            for (int ind = 0; ind &lt; this.lits.length; ind++) {
                if (upWatchCumul &gt;= degreePlusMaxCoef) {
                    // nothing more to watch
                    // note: logic negated to old version // dvh
                    break;
                }
                // while upWatchCumul does not contain enough
                if (!this.voc.isFalsified(this.lits[ind]) &amp;&amp; !this.watched[ind]) {
                    // watch one more
                    upWatchCumul = upWatchCumul + this.coefs[ind];
                    // update arrays watched and watching
                    this.watched[ind] = true;
                    assert this.watchingCount &lt; size();
                    this.watching[this.watchingCount++] = ind;
                    this.voc.watch(this.lits[ind] ^ 1, this);
                    // this new watched literal could change the maximal
                    // coefficient
                    if (this.coefs[ind] &gt; maxCoef) {
                        maxCoef = this.coefs[ind];
                        degreePlusMaxCoef = this.degree + maxCoef;
                    }
                }
            }
            // update watchCumul
            this.watchCumul = upWatchCumul + this.coefs[pIndice];
        }
        return maxCoef;
    }

}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/WatchPb.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/WatchPb.html#452">452</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/WatchPbLong.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/WatchPbLong.html#448">448</a></td></tr><tr class="b"><td colspan='2'><div><pre>                        &amp;&amp; this.lits[j] &lt; litPivot);

                if (i &gt;= j) {
                    break;
                }

                tmp = this.coefs[i];
                this.coefs[i] = this.coefs[j];
                this.coefs[j] = tmp;
                tmp2 = this.lits[i];
                this.lits[i] = this.lits[j];
                this.lits[j] = tmp2;
            }

            sort(from, i);
            sort(i, to);
        }

    }

    @Override
    public String toString() {
        StringBuffer stb = new StringBuffer();

        if (this.lits.length &gt; 0) {
            for (int i = 0; i &lt; this.lits.length; i++) {
                stb.append(&quot; + &quot;);
                stb.append(this.coefs[i]);
                stb.append(&quot;.&quot;);
                stb.append(Lits.toString(this.lits[i]));
                stb.append(&quot;[&quot;);
                stb.append(this.voc.valueToString(this.lits[i]));
                stb.append(&quot;@&quot;);
                stb.append(this.voc.getLevel(this.lits[i]));
                stb.append(&quot;]&quot;);
                stb.append(&quot; &quot;);
            }
            stb.append(&quot;&gt;= &quot;);
            stb.append(this.degree);
        }
        return stb.toString();
    }

    public void assertConstraint(UnitPropagationListener s) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/MinWatchPb.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MinWatchPb.html#325">325</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/MinWatchPbLongCP.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MinWatchPbLongCP.html#326">326</a></td></tr><tr class="b"><td colspan='2'><div><pre>                        &amp;&amp; i != pIndiceWatching
                        &amp;&amp; !this.voc.isSatisfied(this.lits[this.watching[i]])
                        &amp;&amp; !s.enqueue(this.lits[this.watching[i]], this)) {
                    this.voc.watch(p, this);
                    assert !isSatisfiable();
                    return false;
                }
            }
            // if the constraint is added to the undos of p (by propagation),
            // then p should be preserved.
            this.voc.undos(p).push(this);
        }

        // else p is no more watched
        this.watched[pIndice] = false;
        this.watchCumul = upWatchCumul;
        this.watching[pIndiceWatching] = this.watching[--this.watchingCount];

        assert this.watchingCount != 0;
        assert nbOfWatched() == this.watchingCount;

        return true;
    }

    /**
     * Remove the constraint from the solver
     */
    public void remove(UnitPropagationListener upl) {
        for (int i = 0; i &lt; this.watchingCount; i++) {
            this.voc.watches(this.lits[this.watching[i]] ^ 1).remove(this);
            this.watched[this.watching[i]] = false;
        }
        this.watchingCount = 0;
        assert nbOfWatched() == this.watchingCount;
    }

    /**
     * this method is called during backtrack
     * 
     * @param p
     *            un unassigned literal
     */
    public void undo(int p) {
        this.voc.watch(p, this);
        int pIndice = 0;
        while ((this.lits[pIndice] ^ 1) != p) {
            pIndice++;
        }

        assert pIndice &lt; this.lits.length;

        this.watchCumul = this.watchCumul + this.coefs[pIndice];</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/MaxWatchPbLong.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MaxWatchPbLong.html#180">180</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/MaxWatchPbLongCP.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MaxWatchPbLongCP.html#179">179</a></td></tr><tr class="b"><td colspan='2'><div><pre>    public boolean propagate(UnitPropagationListener s, int p) {
        this.voc.watch(p, this);

        assert this.watchCumul &gt;= computeLeftSide() : &quot;&quot; + this.watchCumul
                + &quot;/&quot; + computeLeftSide() + &quot;:&quot; + this.learnt;

        // compute the new value for watchCumul
        long coefP;
        if (this.litToCoeffs == null) {
            // finding the index for p in the array of literals
            int indiceP = 0;
            while ((this.lits[indiceP] ^ 1) != p) {
                indiceP++;
            }

            // compute the new value for watchCumul
            coefP = this.coefs[indiceP];
        } else {
            coefP = this.litToCoeffs.get(p ^ 1);
        }
        long newcumul = this.watchCumul - coefP;

        if (newcumul &lt; this.degree) {
            // there is a conflict
            assert !isSatisfiable();
            return false;
        }

        // if no conflict, not(p) can be propagated
        // allow a later un-assignation
        this.voc.undos(p).push(this);
        // really update watchCumul
        this.watchCumul = newcumul;

        // propagation
        int ind = 0;
        // limit is the margin between the sum of the coefficients of the
        // satisfied+unassigned literals
        // and the degree of the constraint
        long limit = this.watchCumul - this.degree;
        // for each coefficient greater than limit
        while (ind &lt; this.coefs.length &amp;&amp; limit &lt; this.coefs[ind]) {
            // its corresponding literal is implied
            if (this.voc.isUnassigned(this.lits[ind])
                    &amp;&amp; !s.enqueue(this.lits[ind], this)) {
                // if it is not possible then there is a conflict
                assert !isSatisfiable();
                return false;
            }
            ind++;
        }

        assert this.learnt || this.watchCumul &gt;= computeLeftSide();
        assert this.watchCumul &gt;= computeLeftSide();
        return true;
    }</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/WatchPbLong.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/WatchPbLong.html#562">562</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/WatchPbLongCP.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/WatchPbLongCP.html#598">598</a></td></tr><tr class="b"><td colspan='2'><div><pre>            WatchPbLongCP wpb = (WatchPbLongCP) pb;
            if (this.degree != wpb.degree
                    || this.coefs.length != wpb.coefs.length
                    || this.lits.length != wpb.lits.length) {
                return false;
            }
            int lit;
            boolean ok;
            for (int ilit = 0; ilit &lt; this.coefs.length; ilit++) {
                lit = this.lits[ilit];
                ok = false;
                for (int ilit2 = 0; ilit2 &lt; this.coefs.length; ilit2++) {
                    if (wpb.lits[ilit2] == lit) {
                        if (wpb.coefs[ilit2] != this.coefs[ilit]) {
                            return false;
                        }

                        ok = true;
                        break;

                    }
                }
                if (!ok) {
                    return false;
                }
            }
            return true;
        } catch (ClassCastException e) {
            return false;
        }
    }

    @Override
    public int hashCode() {
        long sum = 0;
        for (int p : this.lits) {
            sum += p;
        }
        return (int) sum / this.lits.length;
    }

    public void forwardActivity(double claInc) {
        if (!this.learnt) {
            this.activity += claInc;
        }
    }

    public long[] getLongCoefs() {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/WatchPbLong.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/WatchPbLong.html#189">189</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/WatchPbLongCP.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/WatchPbLongCP.html#197">197</a></td></tr><tr class="b"><td colspan='2'><div><pre>                }
            }
        }
    }

    protected abstract void computeWatches() throws ContradictionException;

    protected abstract void computePropagation(UnitPropagationListener s)
            throws ContradictionException;

    /**
     * to obtain the i-th literal of the constraint
     * 
     * @param i
     *            index of the literal
     * @return the literal
     */
    public int get(int i) {
        return this.lits[i];
    }

    /**
     * to obtain the activity value of the constraint
     * 
     * @return activity value of the constraint
     * @see org.sat4j.minisat.core.Constr#getActivity()
     */
    public double getActivity() {
        return this.activity;
    }

    /**
     * increase activity value of the constraint
     * 
     * @see org.sat4j.minisat.core.Constr#incActivity(double)
     */
    public void incActivity(double claInc) {
        if (this.learnt) {
            this.activity += claInc;
        }
    }

    public void setActivity(double d) {
        if (this.learnt) {
            this.activity = d;
        }
    }

    /**
     * compute the slack of the current constraint slack = poss - degree of the
     * constraint
     * 
     * @return la marge
     */
    public long slackConstraint() {
        return computeLeftSide() - this.degree;
    }

    /**
     * compute the slack of a described constraint slack = poss - degree of the
     * constraint
     * 
     * @param theCoefs
     *            coefficients of the constraint
     * @param theDegree
     *            degree of the constraint
     * @return slack of the constraint
     */
    public long slackConstraint(long[] theCoefs, long theDegree) {
        return computeLeftSide(theCoefs) - theDegree;
    }

    /**
     * compute the sum of the coefficients of the satisfied or non-assigned
     * literals of a described constraint (usually called poss)
     * 
     * @param coefs
     *            coefficients of the constraint
     * @return poss
     */
    public long computeLeftSide(long[] theCoefs) {
        long poss = 0;
        // for each literal
        for (int i = 0; i &lt; this.lits.length; i++) {
            if (!this.voc.isFalsified(this.lits[i])) {
                assert theCoefs[i] &gt;= 0;
                poss = poss + theCoefs[i];
            }
        }
        return poss;
    }

    /**
     * compute the sum of the coefficients of the satisfied or non-assigned
     * literals of a described constraint (usually called poss)
     * 
     * @param coefs
     *            coefficients of the constraint
     * @return poss
     */
    public BigInteger computeLeftSide(BigInteger[] theCoefs) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/WatchPbLong.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/WatchPbLong.html#126">126</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/WatchPbLongCP.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/WatchPbLongCP.html#142">142</a></td></tr><tr class="b"><td colspan='2'><div><pre>        }
        return res;
    }

    /**
     * This predicate tests wether the constraint is assertive at decision level
     * dl
     * 
     * @param dl
     * @return true iff the constraint is assertive at decision level dl.
     */
    public boolean isAssertive(int dl) {
        long slack = 0;
        for (int i = 0; i &lt; this.lits.length; i++) {
            if (this.coefs[i] &gt; 0
                    &amp;&amp; (!this.voc.isFalsified(this.lits[i]) || this.voc
                            .getLevel(this.lits[i]) &gt;= dl)) {
                slack = slack + this.coefs[i];
            }
        }
        slack = slack - this.degree;
        if (slack &lt; 0) {
            return false;
        }
        for (int i = 0; i &lt; this.lits.length; i++) {
            if (this.coefs[i] &gt; 0
                    &amp;&amp; (this.voc.isUnassigned(this.lits[i]) || this.voc
                            .getLevel(this.lits[i]) &gt;= dl)
                    &amp;&amp; slack &lt; this.coefs[i]) {
                return true;
            }
        }
        return false;
    }

    /**
     * compute the reason for the assignment of a literal
     * 
     * @param p
     *            a falsified literal (or Lit.UNDEFINED)
     * @param outReason
     *            list of falsified literals for which the negation is the
     *            reason of the assignment
     * @see org.sat4j.minisat.core.Constr#calcReason(int, IVecInt)
     */
    public void calcReason(int p, IVecInt outReason) {
        long sumfalsified = 0;</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/PBSolverDecorator.java</td><td><a href="./xref/org/sat4j/pb/PBSolverDecorator.html#68">68</a></td></tr><tr class="a"><td>org/sat4j/pb/tools/LexicoDecoratorPB.java</td><td><a href="./xref/org/sat4j/pb/tools/LexicoDecoratorPB.html#123">123</a></td></tr><tr class="b"><td colspan='2'><div><pre>        return this.objs.size();
    }

    public IConstr addAtMost(IVecInt literals, IVecInt coeffs, int degree)
            throws ContradictionException {
        return decorated().addAtMost(literals, coeffs, degree);
    }

    public IConstr addAtMost(IVecInt literals, IVec&lt;BigInteger&gt; coeffs,
            BigInteger degree) throws ContradictionException {
        return decorated().addAtMost(literals, coeffs, degree);
    }

    public IConstr addAtLeast(IVecInt literals, IVecInt coeffs, int degree)
            throws ContradictionException {
        return decorated().addAtLeast(literals, coeffs, degree);
    }

    public IConstr addAtLeast(IVecInt literals, IVec&lt;BigInteger&gt; coeffs,
            BigInteger degree) throws ContradictionException {
        return decorated().addAtLeast(literals, coeffs, degree);
    }

    public IConstr addExactly(IVecInt literals, IVecInt coeffs, int weight)
            throws ContradictionException {
        return decorated().addExactly(literals, coeffs, weight);
    }

    public IConstr addExactly(IVecInt literals, IVec&lt;BigInteger&gt; coeffs,
            BigInteger weight) throws ContradictionException {
        return decorated().addExactly(literals, coeffs, weight);
    }

}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/WatchPb.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/WatchPb.html#464">464</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/WatchPbLongCP.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/WatchPbLongCP.html#496">496</a></td></tr><tr class="b"><td colspan='2'><div><pre>            }

            sort(from, i);
            sort(i, to);
        }

    }

    @Override
    public String toString() {
        StringBuffer stb = new StringBuffer();

        if (this.lits.length &gt; 0) {
            for (int i = 0; i &lt; this.lits.length; i++) {
                stb.append(&quot; + &quot;);
                stb.append(this.coefs[i]);
                stb.append(&quot;.&quot;);
                stb.append(Lits.toString(this.lits[i]));
                stb.append(&quot;[&quot;);
                stb.append(this.voc.valueToString(this.lits[i]));
                stb.append(&quot;@&quot;);
                stb.append(this.voc.getLevel(this.lits[i]));
                stb.append(&quot;]&quot;);
                stb.append(&quot; &quot;);
            }
            stb.append(&quot;&gt;= &quot;);
            stb.append(this.degree);
        }
        return stb.toString();
    }

    public void assertConstraint(UnitPropagationListener s) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/MinWatchPb.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MinWatchPb.html#243">243</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/MinWatchPbLongCP.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MinWatchPbLongCP.html#244">244</a></td></tr><tr class="b"><td colspan='2'><div><pre>        if (outclause.degree &lt;= 0) {
            return null;
        }

        outclause.computeWatches();

        outclause.computePropagation(s);

        return outclause;

    }

    /**
     * Number of really watched literals. It should return the same value as
     * watchingCount.
     * 
     * This method must only be called for assertions.
     * 
     * @return number of watched literals.
     */
    protected int nbOfWatched() {
        int retour = 0;
        for (int ind = 0; ind &lt; this.watched.length; ind++) {
            for (int i = 0; i &lt; this.watchingCount; i++) {
                if (this.watching[i] == ind) {
                    assert this.watched[ind];
                }
            }
            retour += this.watched[ind] ? 1 : 0;
        }
        return retour;
    }

    /**
     * Propagation of a falsified literal
     * 
     * @param s
     *            the solver
     * @param p
     *            the propagated literal (it must be falsified)
     * @return false iff there is a conflict
     */
    public boolean propagate(UnitPropagationListener s, int p) {
        assert nbOfWatched() == this.watchingCount;
        assert this.watchingCount &gt; 1;

        // finding the index for p in the array of literals (pIndice)
        // and in the array of watching (pIndiceWatching)
        int pIndiceWatching = 0;
        while (pIndiceWatching &lt; this.watchingCount
                &amp;&amp; (this.lits[this.watching[pIndiceWatching]] ^ 1) != p) {
            pIndiceWatching++;
        }
        int pIndice = this.watching[pIndiceWatching];

        assert p == (this.lits[pIndice] ^ 1);
        assert this.watched[pIndice];</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/LPStringSolver.java</td><td><a href="./xref/org/sat4j/pb/LPStringSolver.html#431">431</a></td></tr><tr class="a"><td>org/sat4j/pb/LPStringSolver.java</td><td><a href="./xref/org/sat4j/pb/LPStringSolver.html#492">492</a></td></tr><tr class="b"><td colspan='2'><div><pre>            BigInteger weight) throws ContradictionException {
        StringBuffer out = getOut();
        assert literals.size() == coeffs.size();
        this.nbOfConstraints++;
        int n = literals.size();
        if (n &gt; 0) {
            out.append(coeffs.get(0));
            out.append(&quot;x&quot;);
            out.append(literals.get(0));
            out.append(&quot; &quot;);
        }
        BigInteger coeff;
        for (int i = 1; i &lt; n; i++) {
            coeff = coeffs.get(i);
            if (coeff.signum() &gt; 0) {
                out.append(&quot;+ &quot; + coeff);
            } else {
                out.append(&quot;- &quot; + coeff.negate());
            }
            out.append(&quot;x&quot;);
            out.append(literals.get(i));
            out.append(&quot; &quot;);
        }
        out.append(&quot;= &quot;);</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/LPStringSolver.java</td><td><a href="./xref/org/sat4j/pb/LPStringSolver.html#400">400</a></td></tr><tr class="a"><td>org/sat4j/pb/LPStringSolver.java</td><td><a href="./xref/org/sat4j/pb/LPStringSolver.html#461">461</a></td></tr><tr class="b"><td colspan='2'><div><pre>    public IConstr addExactly(IVecInt literals, IVecInt coeffs, int weight)
            throws ContradictionException {
        StringBuffer out = getOut();
        assert literals.size() == coeffs.size();
        this.nbOfConstraints++;
        int n = literals.size();
        if (n &gt; 0) {
            out.append(coeffs.get(0));
            out.append(&quot;x&quot;);
            out.append(literals.get(0));
            out.append(&quot; &quot;);
        }
        int coeff;
        for (int i = 1; i &lt; n; i++) {
            coeff = coeffs.get(i);
            if (coeff &gt; 0) {
                out.append(&quot;+ &quot; + coeff);
            } else {
                out.append(&quot;- &quot; + coeff * -1);
            }
            out.append(&quot;x&quot;);
            out.append(literals.get(i));
            out.append(&quot; &quot;);
        }
        out.append(&quot;= &quot;);</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/reader/OPBReader2007.java</td><td><a href="./xref/org/sat4j/pb/reader/OPBReader2007.html#185">185</a></td></tr><tr class="a"><td>org/sat4j/pb/reader/OPBReader2010.java</td><td><a href="./xref/org/sat4j/pb/reader/OPBReader2010.html#59">59</a></td></tr><tr class="b"><td colspan='2'><div><pre>        super(solver);
    }

    /**
     * read the first comment line to get the number of variables and the number
     * of constraints in the file calls metaData with the data that was read
     * 
     * @throws IOException
     * @throws ParseFormatException
     */
    @Override
    protected void readMetaData() throws IOException, ParseFormatException {
        char c;
        String s;

        // get the number of variables and constraints
        c = get();
        if (c != '*') {
            throw new ParseFormatException(
                    &quot;First line of input file should be a comment&quot;);
        }
        s = readWord();
        if (eof() || !&quot;#variable=&quot;.equals(s)) {
            throw new ParseFormatException(
                    &quot;First line should contain #variable= as first keyword&quot;);
        }

        this.nbVars = Integer.parseInt(readWord());
        this.nbNewSymbols = this.nbVars + 1;

        s = readWord();
        if (eof() || !&quot;#constraint=&quot;.equals(s)) {
            throw new ParseFormatException(
                    &quot;First line should contain #constraint= as second keyword&quot;);
        }

        this.nbConstr = Integer.parseInt(readWord());
        this.charAvailable = false;
        if (!eol()) {
            String rest = this.in.readLine();

            if (rest != null &amp;&amp; rest.contains(&quot;#soft&quot;)) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/MinWatchPb.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MinWatchPb.html#162">162</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/MinWatchPbLongCP.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MinWatchPbLongCP.html#163">163</a></td></tr><tr class="b"><td colspan='2'><div><pre>        while (this.watchCumul - this.coefs[0] &lt; this.degree &amp;&amp; free &gt; 0) {
            free = 0;
            // looking for the literal falsified
            // at the least (lowest ?) level
            maxlevel = -1;
            maxi = -1;
            for (int i = 0; i &lt; this.lits.length; i++) {
                if (this.voc.isFalsified(this.lits[i]) &amp;&amp; !this.watched[i]) {
                    free++;
                    level = this.voc.getLevel(this.lits[i]);
                    if (level &gt; maxlevel) {
                        maxi = i;
                        maxlevel = level;
                    }
                }
            }

            if (free &gt; 0) {
                assert maxi &gt;= 0;
                this.voc.watch(this.lits[maxi] ^ 1, this);
                this.watching[this.watchingCount++] = maxi;
                this.watched[maxi] = true;
                // update of the watchCumul value
                this.watchCumul = this.watchCumul + this.coefs[maxi];</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/tools/PBAdapter.java</td><td><a href="./xref/org/sat4j/pb/tools/PBAdapter.html#68">68</a></td></tr><tr class="a"><td>org/sat4j/pb/tools/XplainPB.java</td><td><a href="./xref/org/sat4j/pb/tools/XplainPB.html#147">147</a></td></tr><tr class="b"><td colspan='2'><div><pre>        return decorated().getObjectiveFunction();
    }

    public IConstr addAtMost(IVecInt literals, IVecInt coeffs, int degree)
            throws ContradictionException {
        throw new UnsupportedOperationException();
    }

    public IConstr addAtMost(IVecInt literals, IVec&lt;BigInteger&gt; coeffs,
            BigInteger degree) throws ContradictionException {
        throw new UnsupportedOperationException();
    }

    public IConstr addAtLeast(IVecInt literals, IVecInt coeffs, int degree)
            throws ContradictionException {
        throw new UnsupportedOperationException();
    }

    public IConstr addAtLeast(IVecInt literals, IVec&lt;BigInteger&gt; coeffs,
            BigInteger degree) throws ContradictionException {
        throw new UnsupportedOperationException();
    }

    public IConstr addExactly(IVecInt literals, IVecInt coeffs, int weight)
            throws ContradictionException {
        throw new UnsupportedOperationException();
    }

    public IConstr addExactly(IVecInt literals, IVec&lt;BigInteger&gt; coeffs,
            BigInteger weight) throws ContradictionException {
        throw new UnsupportedOperationException();
    }</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/WatchPbLong.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/WatchPbLong.html#276">276</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/WatchPbLongCP.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/WatchPbLongCP.html#304">304</a></td></tr><tr class="b"><td colspan='2'><div><pre>            }
        }
        return poss;
    }

    /**
     * compute the sum of the coefficients of the satisfied or non-assigned
     * literals of the current constraint (usually called poss)
     * 
     * @return poss
     */
    public long computeLeftSide() {
        return computeLeftSide(this.coefs);
    }

    /**
     * tests if the constraint is still satisfiable.
     * 
     * this method is only called in assertions.
     * 
     * @return the constraint is satisfiable
     */
    protected boolean isSatisfiable() {
        return computeLeftSide() &gt;= this.degree;
    }

    /**
     * is the constraint a learnt constraint ?
     * 
     * @return true if the constraint is learnt, else false
     * @see org.sat4j.specs.IConstr#learnt()
     */
    public boolean learnt() {
        return this.learnt;
    }

    /**
     * The constraint is the reason of a unit propagation.
     * 
     * @return true
     */
    public boolean locked() {
        for (int p : this.lits) {
            if (this.voc.getReason(p) == this) {
                return true;
            }
        }
        return false;
    }

    /**
     * ppcm : least common multiple for two integers (plus petit commun
     * multiple)
     * 
     * @param a
     *            one integer
     * @param b
     *            the other integer
     * @return the least common multiple of a and b
     */
    protected static BigInteger ppcm(BigInteger a, BigInteger b) {
        return a.divide(a.gcd(b)).multiply(b);
    }

    /**
     * to re-scale the activity of the constraint
     * 
     * @param d
     *            adjusting factor
     */
    public void rescaleBy(double d) {
        this.activity *= d;
    }

    void selectionSort(int from, int to) {
        int i, j, bestIndex;
        long tmp;</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/PseudoBitsAdderDecorator.java</td><td><a href="./xref/org/sat4j/pb/PseudoBitsAdderDecorator.html#188">188</a></td></tr><tr class="a"><td>org/sat4j/pb/tools/XplainPB.java</td><td><a href="./xref/org/sat4j/pb/tools/XplainPB.html#148">148</a></td></tr><tr class="b"><td colspan='2'><div><pre>    }

    public IConstr addAtMost(IVecInt literals, IVecInt coeffs, int degree)
            throws ContradictionException {
        throw new UnsupportedOperationException();
    }

    public IConstr addAtMost(IVecInt literals, IVec&lt;BigInteger&gt; coeffs,
            BigInteger degree) throws ContradictionException {
        throw new UnsupportedOperationException();
    }

    public IConstr addAtLeast(IVecInt literals, IVecInt coeffs, int degree)
            throws ContradictionException {
        throw new UnsupportedOperationException();
    }

    public IConstr addAtLeast(IVecInt literals, IVec&lt;BigInteger&gt; coeffs,
            BigInteger degree) throws ContradictionException {
        throw new UnsupportedOperationException();
    }

    public IConstr addExactly(IVecInt literals, IVecInt coeffs, int weight)
            throws ContradictionException {
        throw new UnsupportedOperationException();
    }

    public IConstr addExactly(IVecInt literals, IVec&lt;BigInteger&gt; coeffs,
            BigInteger weight) throws ContradictionException {
        throw new UnsupportedOperationException();
    }
}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/PseudoBitsAdderDecorator.java</td><td><a href="./xref/org/sat4j/pb/PseudoBitsAdderDecorator.html#188">188</a></td></tr><tr class="a"><td>org/sat4j/pb/tools/PBAdapter.java</td><td><a href="./xref/org/sat4j/pb/tools/PBAdapter.html#69">69</a></td></tr><tr class="b"><td colspan='2'><div><pre>    }

    public IConstr addAtMost(IVecInt literals, IVecInt coeffs, int degree)
            throws ContradictionException {
        throw new UnsupportedOperationException();
    }

    public IConstr addAtMost(IVecInt literals, IVec&lt;BigInteger&gt; coeffs,
            BigInteger degree) throws ContradictionException {
        throw new UnsupportedOperationException();
    }

    public IConstr addAtLeast(IVecInt literals, IVecInt coeffs, int degree)
            throws ContradictionException {
        throw new UnsupportedOperationException();
    }

    public IConstr addAtLeast(IVecInt literals, IVec&lt;BigInteger&gt; coeffs,
            BigInteger degree) throws ContradictionException {
        throw new UnsupportedOperationException();
    }

    public IConstr addExactly(IVecInt literals, IVecInt coeffs, int weight)
            throws ContradictionException {
        throw new UnsupportedOperationException();
    }

    public IConstr addExactly(IVecInt literals, IVec&lt;BigInteger&gt; coeffs,
            BigInteger weight) throws ContradictionException {
        throw new UnsupportedOperationException();
    }</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/WatchPbLong.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/WatchPbLong.html#370">370</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/WatchPbLongCP.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/WatchPbLongCP.html#404">404</a></td></tr><tr class="b"><td colspan='2'><div><pre>        }
    }

    /**
     * the constraint is learnt
     */
    public void setLearnt() {
        this.learnt = true;
    }

    /**
     * simplify the constraint (if it is satisfied)
     * 
     * @return true if the constraint is satisfied, else false
     */
    public boolean simplify() {
        long cumul = 0;

        int i = 0;
        while (i &lt; this.lits.length &amp;&amp; cumul &lt; this.degree) {
            if (this.voc.isSatisfied(this.lits[i])) {
                // strong measure
                cumul = cumul + this.coefs[i];
            }
            i++;
        }

        return cumul &gt;= this.degree;
    }

    public final int size() {
        return this.lits.length;
    }

    /**
     * sort coefficient and literal arrays
     */
    protected final void sort() {
        assert this.lits != null;
        if (this.coefs.length &gt; 0) {
            this.sort(0, size());</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/LPStringSolver.java</td><td><a href="./xref/org/sat4j/pb/LPStringSolver.html#113">113</a></td></tr><tr class="a"><td>org/sat4j/pb/OPBStringSolver.java</td><td><a href="./xref/org/sat4j/pb/OPBStringSolver.html#110">110</a></td></tr><tr class="b"><td colspan='2'><div><pre>                getOut().append(&quot;-1 x&quot; + -p + &quot; &gt;= 0 ;\n&quot;);
            }
            this.nbOfConstraints++;
        }
        throw new TimeoutException();
    }

    @Override
    public boolean isSatisfiable(IVecInt assumps, boolean global)
            throws TimeoutException {
        return super.isSatisfiable(assumps, global);
    }

    public IConstr addPseudoBoolean(IVecInt lits, IVec&lt;BigInteger&gt; coeffs,
            boolean moreThan, BigInteger d) throws ContradictionException {
        if (moreThan) {
            return addAtLeast(lits, coeffs, d);
        }
        return addAtMost(lits, coeffs, d);
    }

    public void setObjectiveFunction(ObjectiveFunction obj) {
        this.obj = obj;
    }

    @Override
    public IConstr addAtLeast(IVecInt literals, int degree)
            throws ContradictionException {
        StringBuffer out = getOut();
        this.nbOfConstraints++;
        int negationweight = 0;
        int p;</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/MinWatchPb.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MinWatchPb.html#325">325</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/MinWatchPbLong.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MinWatchPbLong.html#324">324</a></td></tr><tr class="b"><td colspan='2'><div><pre>                        &amp;&amp; i != pIndiceWatching
                        &amp;&amp; !this.voc.isSatisfied(this.lits[this.watching[i]])
                        &amp;&amp; !s.enqueue(this.lits[this.watching[i]], this)) {
                    this.voc.watch(p, this);
                    assert !isSatisfiable();
                    return false;
                }
            }
            // if the constraint is added to the undos of p (by propagation),
            // then p should be preserved.
            this.voc.undos(p).push(this);
        }

        // else p is no more watched
        this.watched[pIndice] = false;
        this.watchCumul = upWatchCumul;
        this.watching[pIndiceWatching] = this.watching[--this.watchingCount];

        assert this.watchingCount != 0;
        assert nbOfWatched() == this.watchingCount;

        return true;
    }</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/WatchPbLong.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/WatchPbLong.html#436">436</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/WatchPbLongCP.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/WatchPbLongCP.html#467">467</a></td></tr><tr class="b"><td colspan='2'><div><pre>            int i = from - 1;
            int j = to;
            int tmp2;

            for (;;) {
                do {
                    i++;
                } while (this.coefs[i] &gt; pivot || this.coefs[i] == pivot
                        &amp;&amp; this.lits[i] &gt; litPivot);
                do {
                    j--;
                } while (pivot &gt; this.coefs[j] || this.coefs[j] == pivot
                        &amp;&amp; this.lits[j] &lt; litPivot);

                if (i &gt;= j) {
                    break;
                }

                tmp = this.coefs[i];
                this.coefs[i] = this.coefs[j];
                this.coefs[j] = tmp;</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/MinWatchPbLong.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MinWatchPbLong.html#238">238</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/MinWatchPbLongCP.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MinWatchPbLongCP.html#241">241</a></td></tr><tr class="b"><td colspan='2'><div><pre>        MinWatchPbLongCP outclause = new MinWatchPbLongCP(voc, lits, coefs,
                degree, sumCoefs);

        if (outclause.degree &lt;= 0) {
            return null;
        }

        outclause.computeWatches();

        outclause.computePropagation(s);

        return outclause;

    }

    /**
     * Number of really watched literals. It should return the same value as
     * watchingCount.
     * 
     * This method must only be called for assertions.
     * 
     * @return number of watched literals.
     */
    protected int nbOfWatched() {
        int retour = 0;
        for (int ind = 0; ind &lt; this.watched.length; ind++) {
            for (int i = 0; i &lt; this.watchingCount; i++) {
                if (this.watching[i] == ind) {
                    assert this.watched[ind];
                }
            }
            retour += this.watched[ind] ? 1 : 0;
        }
        return retour;
    }</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/LPStringSolver.java</td><td><a href="./xref/org/sat4j/pb/LPStringSolver.html#53">53</a></td></tr><tr class="a"><td>org/sat4j/pb/OPBStringSolver.java</td><td><a href="./xref/org/sat4j/pb/OPBStringSolver.html#50">50</a></td></tr><tr class="b"><td colspan='2'><div><pre>public class OPBStringSolver extends DimacsStringSolver implements IPBSolver {

    private static final String FAKE_I_CONSTR_MSG = &quot;Fake IConstr&quot;;

    /**
	 * 
	 */
    private static final long serialVersionUID = 1L;

    private int indxConstrObj;

    private int nbOfConstraints;

    private ObjectiveFunction obj;

    private boolean inserted = false;

    private static final IConstr FAKE_CONSTR = new IConstr() {

        public int size() {
            throw new UnsupportedOperationException(FAKE_I_CONSTR_MSG);
        }

        public boolean learnt() {
            throw new UnsupportedOperationException(FAKE_I_CONSTR_MSG);
        }

        public double getActivity() {
            throw new UnsupportedOperationException(FAKE_I_CONSTR_MSG);
        }

        public int get(int i) {
            throw new UnsupportedOperationException(FAKE_I_CONSTR_MSG);
        }

        public boolean canBePropagatedMultipleTimes() {
            throw new UnsupportedOperationException(FAKE_I_CONSTR_MSG);
        }
    };

    /**
	 * 
	 */
    public OPBStringSolver() {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/WatchPbLong.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/WatchPbLong.html#353">353</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/WatchPbLongCP.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/WatchPbLongCP.html#382">382</a></td></tr><tr class="b"><td colspan='2'><div><pre>        int tmp2;

        for (i = from; i &lt; to - 1; i++) {
            bestIndex = i;
            for (j = i + 1; j &lt; to; j++) {
                if (this.coefs[j] &gt; this.coefs[bestIndex]
                        || this.coefs[j] == this.coefs[bestIndex]
                        &amp;&amp; this.lits[j] &gt; this.lits[bestIndex]) {
                    bestIndex = j;
                }
            }
            tmp = this.coefs[i];
            this.coefs[i] = this.coefs[bestIndex];
            this.coefs[bestIndex] = tmp;</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/OPBStringSolver.java</td><td><a href="./xref/org/sat4j/pb/OPBStringSolver.html#50">50</a></td></tr><tr class="a"><td>org/sat4j/pb/UserFriendlyPBStringSolver.java</td><td><a href="./xref/org/sat4j/pb/UserFriendlyPBStringSolver.html#48">48</a></td></tr><tr class="b"><td colspan='2'><div><pre>public class UserFriendlyPBStringSolver&lt;T&gt; extends DimacsStringSolver implements
        IPBSolver {

    private static final String FAKE_I_CONSTR_MSG = &quot;Fake IConstr&quot;;

    /**
	 * 
	 */
    private static final long serialVersionUID = 1L;

    private int indxConstrObj;

    private int nbOfConstraints;

    private ObjectiveFunction obj;

    private boolean inserted = false;

    private static final IConstr FAKE_CONSTR = new IConstr() {

        public int size() {
            throw new UnsupportedOperationException(FAKE_I_CONSTR_MSG);
        }

        public boolean learnt() {
            throw new UnsupportedOperationException(FAKE_I_CONSTR_MSG);
        }

        public double getActivity() {
            throw new UnsupportedOperationException(FAKE_I_CONSTR_MSG);
        }

        public int get(int i) {
            throw new UnsupportedOperationException(FAKE_I_CONSTR_MSG);
        }

        public boolean canBePropagatedMultipleTimes() {
            throw new UnsupportedOperationException(FAKE_I_CONSTR_MSG);
        }
    };</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/LPStringSolver.java</td><td><a href="./xref/org/sat4j/pb/LPStringSolver.html#315">315</a></td></tr><tr class="a"><td>org/sat4j/pb/OPBStringSolver.java</td><td><a href="./xref/org/sat4j/pb/OPBStringSolver.html#242">242</a></td></tr><tr class="b"><td colspan='2'><div><pre>    }

    @Override
    public int newVar(int howmany) {
        StringBuffer out = getOut();
        setNbVars(howmany);
        // to add later the number of constraints
        this.indxConstrObj = out.length();
        out.append(&quot;\n&quot;);
        return howmany;
    }

    @Override
    public void setExpectedNumberOfClauses(int nb) {
    }

    public ObjectiveFunction getObjectiveFunction() {
        return this.obj;
    }

    @Override
    public int nConstraints() {
        return this.nbOfConstraints;
    }

    public IConstr addAtMost(IVecInt literals, IVecInt coeffs, int degree)
            throws ContradictionException {
        StringBuffer out = getOut();
        assert literals.size() == coeffs.size();
        this.nbOfConstraints++;</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/LPStringSolver.java</td><td><a href="./xref/org/sat4j/pb/LPStringSolver.html#53">53</a></td></tr><tr class="a"><td>org/sat4j/pb/UserFriendlyPBStringSolver.java</td><td><a href="./xref/org/sat4j/pb/UserFriendlyPBStringSolver.html#48">48</a></td></tr><tr class="b"><td colspan='2'><div><pre>public class UserFriendlyPBStringSolver&lt;T&gt; extends DimacsStringSolver implements
        IPBSolver {

    private static final String FAKE_I_CONSTR_MSG = &quot;Fake IConstr&quot;;

    /**
	 * 
	 */
    private static final long serialVersionUID = 1L;

    private int indxConstrObj;

    private int nbOfConstraints;

    private ObjectiveFunction obj;

    private boolean inserted = false;

    private static final IConstr FAKE_CONSTR = new IConstr() {

        public int size() {
            throw new UnsupportedOperationException(FAKE_I_CONSTR_MSG);
        }

        public boolean learnt() {
            throw new UnsupportedOperationException(FAKE_I_CONSTR_MSG);
        }

        public double getActivity() {
            throw new UnsupportedOperationException(FAKE_I_CONSTR_MSG);
        }

        public int get(int i) {
            throw new UnsupportedOperationException(FAKE_I_CONSTR_MSG);
        }

        public boolean canBePropagatedMultipleTimes() {
            throw new UnsupportedOperationException(FAKE_I_CONSTR_MSG);
        }
    };</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/WatchPb.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/WatchPb.html#301">301</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/WatchPbLongCP.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/WatchPbLongCP.html#328">328</a></td></tr><tr class="b"><td colspan='2'><div><pre>    }

    /**
     * is the constraint a learnt constraint ?
     * 
     * @return true if the constraint is learnt, else false
     * @see org.sat4j.specs.IConstr#learnt()
     */
    public boolean learnt() {
        return this.learnt;
    }

    /**
     * The constraint is the reason of a unit propagation.
     * 
     * @return true
     */
    public boolean locked() {
        for (int p : this.lits) {
            if (this.voc.getReason(p) == this) {
                return true;
            }
        }
        return false;
    }

    /**
     * ppcm : least common multiple for two integers (plus petit commun
     * multiple)
     * 
     * @param a
     *            one integer
     * @param b
     *            the other integer
     * @return the least common multiple of a and b
     */
    protected static BigInteger ppcm(BigInteger a, BigInteger b) {
        return a.divide(a.gcd(b)).multiply(b);
    }

    /**
     * to re-scale the activity of the constraint
     * 
     * @param d
     *            adjusting factor
     */
    public void rescaleBy(double d) {
        this.activity *= d;
    }

    void selectionSort(int from, int to) {
        int i, j, bestIndex;</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/MaxWatchPbLong.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MaxWatchPbLong.html#71">71</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/MaxWatchPbLongCP.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MaxWatchPbLongCP.html#71">71</a></td></tr><tr class="b"><td colspan='2'><div><pre>    private MaxWatchPbLongCP(ILits voc, IDataStructurePB mpb) {

        super(mpb);
        this.voc = voc;

        this.activity = 0;
        this.watchCumul = 0;
        if (this.coefs.length &gt; MaxWatchPb.LIMIT_FOR_MAP) {
            this.litToCoeffs = new HashMap&lt;Integer, Long&gt;(this.coefs.length);
            for (int i = 0; i &lt; this.coefs.length; i++) {
                this.litToCoeffs.put(this.lits[i], this.coefs[i]);
            }
        } else {
            this.litToCoeffs = null;
        }
    }

    /**
     * Builds a PB constraint for a0.x0 + a1.x1 + ... + an.xn &gt;= k
     * 
     * @param voc
     *            all the possible variables (vocabulary)
     * @param lits
     *            literals of the constraint (x0,x1, ... xn)
     * @param coefs
     *            coefficients of the left side of the constraint (a0, a1, ...
     *            an)
     * @param degree
     *            degree of the constraint (k)
     */
    private MaxWatchPbLongCP(ILits voc, int[] lits, BigInteger[] coefs,</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/MaxWatchPb.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MaxWatchPb.html#132">132</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/MaxWatchPbLongCP.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MaxWatchPbLongCP.html#127">127</a></td></tr><tr class="b"><td colspan='2'><div><pre>        for (int i = 0; i &lt; this.lits.length; i++) {
            if (this.voc.isFalsified(this.lits[i])) {
                if (this.learnt) {
                    this.voc.undos(this.lits[i] ^ 1).push(this);
                    this.voc.watch(this.lits[i] ^ 1, this);
                }
            } else {
                // updating of the initial value for the counter
                this.voc.watch(this.lits[i] ^ 1, this);
                this.watchCumul = this.watchCumul + this.coefs[i];</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/OriginalBinaryClausePB.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/OriginalBinaryClausePB.html#42">42</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/OriginalHTClausePB.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/OriginalHTClausePB.html#42">42</a></td></tr><tr class="b"><td colspan='2'><div><pre>    public OriginalHTClausePB(IVecInt ps, ILits voc) {
        super(ps, voc);
    }

    /**
     * 
     */
    private static final long serialVersionUID = 1L;

    public IVecInt computeAnImpliedClause() {
        return null;
    }

    public BigInteger getCoef(int literal) {
        return BigInteger.ONE;
    }

    public BigInteger[] getCoefs() {
        BigInteger[] tmp = new BigInteger[size()];
        for (int i = 0; i &lt; tmp.length; i++) {
            tmp[i] = BigInteger.ONE;
        }
        return tmp;
    }

    public BigInteger getDegree() {
        return BigInteger.ONE;
    }

    /**
     * Creates a brand new clause, presumably from external data. Performs all
     * sanity checks.
     * 
     * @param s
     *            the object responsible for unit propagation
     * @param voc
     *            the vocabulary
     * @param literals
     *            the literals to store in the clause
     * @return the created clause or null if the clause should be ignored
     *         (tautology for example)
     */
    public static OriginalHTClausePB brandNewClause(UnitPropagationListener s,</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/LearntBinaryClausePB.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/LearntBinaryClausePB.html#41">41</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/OriginalBinaryClausePB.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/OriginalBinaryClausePB.html#42">42</a></td></tr><tr class="b"><td colspan='2'><div><pre>    public OriginalBinaryClausePB(IVecInt ps, ILits voc) {
        super(ps, voc);
        // TODO Auto-generated constructor stub
    }

    /**
     * 
     */
    private static final long serialVersionUID = 1L;

    public IVecInt computeAnImpliedClause() {
        return null;
    }

    public BigInteger getCoef(int literal) {
        return BigInteger.ONE;
    }

    public BigInteger[] getCoefs() {
        BigInteger[] tmp = new BigInteger[size()];
        for (int i = 0; i &lt; tmp.length; i++) {
            tmp[i] = BigInteger.ONE;
        }
        return tmp;
    }

    public BigInteger getDegree() {
        return BigInteger.ONE;
    }</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/MinWatchPbLong.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MinWatchPbLong.html#368">368</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/MinWatchPbLongCP.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MinWatchPbLongCP.html#368">368</a></td></tr><tr class="b"><td colspan='2'><div><pre>    public void undo(int p) {
        this.voc.watch(p, this);
        int pIndice = 0;
        while ((this.lits[pIndice] ^ 1) != p) {
            pIndice++;
        }

        assert pIndice &lt; this.lits.length;

        this.watchCumul = this.watchCumul + this.coefs[pIndice];

        assert this.watchingCount == nbOfWatched();

        this.watched[pIndice] = true;
        this.watching[this.watchingCount++] = pIndice;

        assert this.watchingCount == nbOfWatched();
    }

    /**
     * build a pseudo boolean constraint from a specific data structure. For
     * learnt constraints.
     * 
     * @param s
     *            a unit propagation listener (usually the solver)
     * @param mpb
     *            data structure which contains literals of the constraint,
     *            coefficients (a0, a1, ... an), and the degree of the
     *            constraint (k). The constraint is a &quot;more than&quot; constraint.
     * @return a new PB constraint or null if a trivial inconsistency is
     *         detected.
     */
    public static WatchPbLongCP normalizedWatchPbNew(ILits voc,</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/constraints/pb/MinWatchPb.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MinWatchPb.html#243">243</a></td></tr><tr class="a"><td>org/sat4j/pb/constraints/pb/MinWatchPbLong.java</td><td><a href="./xref/org/sat4j/pb/constraints/pb/MinWatchPbLong.html#241">241</a></td></tr><tr class="b"><td colspan='2'><div><pre>        if (outclause.degree &lt;= 0) {
            return null;
        }

        outclause.computeWatches();

        outclause.computePropagation(s);

        return outclause;

    }

    /**
     * Number of really watched literals. It should return the same value as
     * watchingCount.
     * 
     * This method must only be called for assertions.
     * 
     * @return number of watched literals.
     */
    protected int nbOfWatched() {
        int retour = 0;
        for (int ind = 0; ind &lt; this.watched.length; ind++) {
            for (int i = 0; i &lt; this.watchingCount; i++) {
                if (this.watching[i] == ind) {
                    assert this.watched[ind];
                }
            }
            retour += this.watched[ind] ? 1 : 0;
        }
        return retour;
    }</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/OPBStringSolver.java</td><td><a href="./xref/org/sat4j/pb/OPBStringSolver.html#357">357</a></td></tr><tr class="a"><td>org/sat4j/pb/OPBStringSolver.java</td><td><a href="./xref/org/sat4j/pb/OPBStringSolver.html#375">375</a></td></tr><tr class="b"><td colspan='2'><div><pre>            BigInteger weight) throws ContradictionException {
        StringBuffer out = getOut();
        assert literals.size() == coeffs.size();
        this.nbOfConstraints++;
        for (int i = 0; i &lt; literals.size(); i++) {
            out.append(coeffs.get(i));
            out.append(&quot; x&quot;);
            out.append(literals.get(i));
            out.append(&quot; &quot;);
        }
        out.append(&quot;= &quot;);
        out.append(weight);
        out.append(&quot; ;\n&quot;);
        return FAKE_CONSTR;
    }</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/sat4j/pb/OPBStringSolver.java</td><td><a href="./xref/org/sat4j/pb/OPBStringSolver.html#301">301</a></td></tr><tr class="a"><td>org/sat4j/pb/OPBStringSolver.java</td><td><a href="./xref/org/sat4j/pb/OPBStringSolver.html#319">319</a></td></tr><tr class="b"><td colspan='2'><div><pre>            BigInteger degree) throws ContradictionException {
        StringBuffer out = getOut();
        assert literals.size() == coeffs.size();
        this.nbOfConstraints++;
        for (int i = 0; i &lt; literals.size(); i++) {
            out.append(coeffs.get(i));
            out.append(&quot; x&quot;);
            out.append(literals.get(i));
            out.append(&quot; &quot;);
        }
        out.append(&quot;&gt;= &quot;);
        out.append(degree);
        out.append(&quot; ;\n&quot;);
        return FAKE_CONSTR;

    }</pre></div></td></tr></table></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
              Copyright &#169;                    2013
                        <a href="http://www.cril.univ-artois.fr/">Centre de Recherche en Informatique de Lens (CRIL)</a>.
            All Rights Reserved.      
        
                  </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
